\section{Relational Colour Refinement}
\label{sec:RelationalColourRefinement}

Relational structures are a very important and interesting extension of graphs.
They can be found in various situation, for example in relational database theory where they are used to model the structure of databases \cite{abiteboul1996FoundationsDatabases}.
In this section we want to look at the Relational Colour Refinement algorithm, short RCR. 
It was defined by Scheidt and Schweikardt in \cite{scheidt2025ColorRefinement} as an extension of Colour Refinement for relational structures.
The algorithm is similar to the adaptation of classical Colour Refinement for binary structures and has characterisations analogous to classical Colour Refinement.
Let us begin by defining RCR and applying it to a small example.

\subsection{RCR and Binary Structures}

The idea of RCR is to apply Colour Refinement on the tuples that appear in a relation.
This can then be seen as a binary structure, on which the before mentioned Colour Refinement algorithm can be applied.
To define RCR, we need the following definitions.

\begin{definition}[Atomic and shared types]
	Let $\sigma$ be a relational signature and $\mathfrak A$ be a $\sigma$-structure.
	For every $\mathbf a \in \mathbf A$ we define $\atp(\mathbf a)\coloneqq \{R \in \sigma : \mathbf a\in R\}$ as the set of relations that include $\mathbf a$.
	For every tuple $\mathbf a\in \mathbf A$ of length $n$ and every tuple $\mathbf b\in \mathbf A$ of length $m$ we define $\stp(\mathbf a, \mathbf b)\coloneqq\{(i, j) \in [n]\times [m] : \mathbf a_i=\mathbf b_j\}$ as the set of all pairs of indices which denote the elements that appear in both $\mathbf a$ and $\mathbf b$.
	We call $\atp(\mathbf a)$ the atomic type of $\mathbf a$ and call $\stp(\mathbf a,\mathbf b)$ the shared type of $\mathbf a$ and $\mathbf b$.
	As shorthand notation we write $\stp(\mathbf a)$ for $\stp(\mathbf a, \mathbf a)$.
\end{definition}

We can now define Relational Colour Refinement.
For every $\mathbf a\in \mathbf A$ we iteratively construct a colour $\rho_i(\mathbf a)$.
We begin by defining the initial colour using the atomic and shared type of $\mathbf a$ itself.
Formally, $\rho_0(\mathbf a)\coloneqq(\atp(\mathbf a), \stp(\mathbf a))$.
For every $i \in \mathbb N_{\geq 1}$ the colour $\rho_i(\mathbf a)$ is made up of $\rho_{i-1}(\mathbf a)$ and the colour of the last round for every tuple that $\mathbf a$ shares an element with, in addition to the information which elements are shared.
This is formalised as $\rho_{i+1}(\mathbf a)\coloneqq(\rho_{i}(\mathbf a), N_{i+1}^{\mathfrak A}(\mathbf a))$, where
$$N_{i+1}^{\mathfrak A}\coloneqq \multiset{(\stp(\mathbf a, \mathbf b), \rho_{i}(\mathbf b)) : \mathbf b\in \mathbf A, \stp(\mathbf a, \mathbf b)\neq \emptyset}.$$
It can easily be verified that if $\rho_i(\mathbf a) \neq \rho_i(\mathbf b)$, then $\rho_{i+1}(\mathbf a)\neq\rho_{i+1}(\mathbf b)$, we therefore get a refinement.
This also means there must be a smallest $i_{\mathfrak A} \leq \mathbf A$, such that for every $\mathbf a, \mathbf b\in \mathbf A$, we have that $\rho_{i_{\mathfrak A}}(\mathbf a) = \rho_{i_{\mathfrak A}}(\mathbf b)$ if, and only if, $\rho_{i_{\mathfrak A}+1}(\mathbf a) = \rho_{i_{\mathfrak A}+1}(\mathbf b)$, we then call this colouring the stable colouring.
For a relational structure $\mathfrak A$ and $i\in \mathbb N$ we define $\operatorname{RC}_i(\mathfrak A)\coloneqq\{\rho_i(\mathbf a) : \mathbf a \in \mathbf A\}$ as the set of colours that get constructed in the $i$-th round of RCR.
Further, for a relational structure $\mathfrak A$, $i\in \mathbb N$ and $c\in \operatorname{RC}_i(\mathfrak A)$ we write $\operatorname{mult}_{\mathfrak A}(c)\coloneqq \vert \{\mathbf a\in \mathbf A : \rho_i(\mathbf a)=c\}\vert$ for the number of occurrences of the colour $c$.
Finally, for two $\sigma$-structures $\mathfrak A$ and $\mathfrak B$ we say that Relational Colour Refinement distinguishes $\mathfrak A$ and $\mathfrak B$, if there is an $i \leq \max\{i_{\mathfrak A}, i_{\mathfrak B}\}$ and a colour $c\in \operatorname{RC}_i(\mathfrak A) \cup \operatorname{RC}_i(\mathfrak B)$ such that $\operatorname{mult}_{\mathfrak A}(c)\neq \operatorname{mult}_{\mathfrak B}(c)$.

When comparing this algorithm with the Colour Refinement algorithm for binary structures, we notice similarities.
In fact, it is possible to interpret a relational structure as a binary structure, on which classical Colour Refinement can be applied with an equivalent result to Relational Colour Refinement on the original structure.
For a relational signature $\sigma$ we define a signature $\widehat{\sigma}\coloneqq \{E_{i,j}/2 : i,j \in [\operatorname{ar}(\sigma)]\} \cup \{U_R/1 : R\in \sigma\}$.
For a $\sigma$-structure $\mathfrak A$, we can now define a binary structure $\mathcal{G}_{\mathfrak A}$ of signature $\widehat{\sigma}$.
The universe of $\mathcal{G}_{\mathfrak A}$ is defined as $V(\mathcal{G})_{\mathfrak A}=\{w_{\mathbf a} : \mathbf a \in \mathbf A\}$.
In words, we create a new element $w_{\mathbf a}$ for every tuple $\mathbf a \in \mathbf A$.
The relations are then defined as follows.
For $R\in \sigma$ we set 
$$U_R^{\mathcal{G}_{\mathfrak A}}\coloneqq \{w_{\mathbf a} : \mathbf a \in R\}$$ 
and for $i,j \in [\operatorname{ar}(\sigma)]$ we set 
$$E_{i,j}^{\mathcal{G}_{\mathfrak A}}\coloneqq \{(w_{\mathbf a}, w_{\mathbf b}) : (i, j) \in \stp(\mathbf a, \mathbf b)\}.$$
It was then proved by Scheidt and Schweikardt \cite{scheidt2025ColorRefinement} that, when identifying $\mathbf a$ with $w_{\mathbf a}$ for every $\mathbf a\in \mathbf A$, Colour Refinement on $\mathcal{G}_{\mathfrak A}$ is equivalent, or rather induces the same partition of the tuples in every round, as Relational Colour Refinement on $\mathfrak A$.

\subsubsection{An Example for Relational Colour Refinement}

We want to illustrate this with a small example.
We choose the signature $\sigma=\{R/2, T/3\}$ and a $\sigma$-structure $\mathfrak A=(A,R^{\mathfrak A},T^{\mathfrak A})$ with $A=\{a,b,c,d\}$, $R^{\mathfrak A}=\{(a,b)\}$ and $T^{\mathfrak A}=\{(a,c,d),(b,c,d)\}$.
A graphical representation can be found in Figure \ref{fig:verySimpleRelStruc}.
When applying the transformation described above, we get the signature $\widehat{\sigma}=\{E_{(i,j)} : i,j \in [3]\}\cup\{U_T, U_R\}$.
The complete definition of $\mathcal{G}_{\mathfrak A}$ can be seen in Figure \ref{fig:transformedMultigraph}, where an edge with the label $ij$ from element $a$ to $b$ represents a tuple $(a,b)\in E_{i,j}^{\mathcal{G}_{\mathfrak A}}$, shared edges are contracted and self-loops are omitted.

\begin{figure}
	\centering
	\subcaptionbox{The structure $\mathfrak A$, where the blue edge represents $R$ and the red edges represent $T$.\label{fig:verySimpleRelStruc}}[0.49\textwidth]{
		\centering
		\begin{tikzpicture}
			\node[] at (0,0) (a) {$a$};
			\node[] at (2, 0) (b) {$b$};
			\node[] at (0, -2) (c) {$c$};
			\node[] at (2, -2) (d) {$d$};
			
			\node[fit=(a) (c) (d)] (acd) {};
			\draw[rounded corners=20pt, thick, rwth-red] ($(acd.north west)+(0,0.4)$) -- (acd.south west) -- ($(acd.south east)+(0.4,0)$) -- cycle;
			
			\node[fit=(b) (c) (d)] (bcd) {};
			\draw[rounded corners=20pt, thick, rwth-red] ($(bcd.north east)+(0,0.4)$) -- (bcd.south east) -- ($(bcd.south west)+(-0.4, 0)$) -- cycle;
			
			\node[draw, rounded corners=10pt, thick, rwth-blue, fit=(a) (b)] {};
		\end{tikzpicture}
	}
	\hspace*{\fill}
	\subcaptionbox{The binary structure $\mathcal{G}_{\mathfrak A}$, where the blue circle represents $U_R$ and the red rectangles represent $U_T$. \label{fig:transformedMultigraph}}[0.49\textwidth]{
		\centering
		\begin{tikzpicture}[node distance=2cm]
			\node[draw, circle, thick, rwth-blue] (ab) {$w_{(a,b)}$};
			\node[draw, thick, rwth-red, below left=of ab] (acd) {$w_{(a,c,d)}$};
			\node[draw, thick, rwth-red, below right=of ab] (bcd) {$w_{(b,c,d)}$};
			
			\draw
			(ab) edge[shorten >=0.05cm, shorten <=0.05cm, ->, above, bend right=10] node {$11$} (acd)
			(acd) edge[shorten >=0.05cm, shorten <=0.05cm, ->, below, bend right=10] node {$11$} (ab)
			
			(ab) edge[shorten >=0.05cm, shorten <=0.05cm, ->, above, bend left=10] node {$21$} (bcd)
			(bcd) edge[shorten >=0.05cm, shorten <=0.05cm, ->, below, bend left=10] node {$12$} (ab)
			
			(acd) edge[shorten >=0.05cm, shorten <=0.05cm, ->, below, bend left=10] node {$22,33$} (bcd)
			(bcd) edge[shorten >=0.05cm, shorten <=0.05cm, ->, below, bend left=10] node {$22,33$} (acd);
		\end{tikzpicture}
	}
	\caption{A relational structure $\mathfrak A$ of signature $\sigma=\{R/2, T/3\}$ and the binary structure $\mathcal{G}_{\mathfrak{A}}$ that encodes it.}
\end{figure}

We now want to apply RCR on $\mathfrak A$ and then classical CR on $\mathcal{G}_{\mathfrak A}$.
By this we will see that both algorithms generate the same partition of elements.
By the definition it is obvious that $\rho_0((a,b))=(\{R\},\{(1,1),(2,2)\})$ and $\rho_0((a,c,d))=\rho_0((b,c,d))=(\{T\}, \{(1,1),(2,2),(3,3)\})$.
Thus $(a,b)$ already has a different colour from the other two tuples.
In the next step $(a,c,d)$ and $(b,c,d)$ will also receive different colours.
Concretely, we have
\begin{align*}
	\rho_1((a,c,d))=(\rho_0((a,c,d)), \leftmultiset
		&(\{(1,1)\}, \rho_0((a,b))), \\
		&(\{(2,2),(3,3)\}, \rho_0((b,c,d))), \\
		&(\{(1,1),(2,2),(3,3)\}, \rho_0((a,c,d)))
	\rightmultiset)
\end{align*}
and
\begin{align*}
	\rho_1((b,c,d))=(\rho_0((b,c,d)), \leftmultiset 
		&(\{(1,2)\}, \rho_0((a,b))), \\
		&(\{(2,2),(3,3)\}, \rho_0((a,c,d))), \\
		&(\{(1,1),(2,2),(3,3)\}, \rho_0((b,c,d)))
	\rightmultiset).
\end{align*}
It can thus be seen that $\rho_1((a,c,d))\neq \rho_1((b,c,d))$.
The algorithm now terminates as every element has its own colour.

We will now get the same results when applying classical Colour Refinement to $\mathcal{G}_{\mathfrak A}$.
Similarly to RCR, we have $\gamma_0(w_{(a,b)})=(\{U_R\}, \{E_{1,1},E_{2,2}\})$ and $\gamma_0(w_{(a,c,d)})=\gamma_0(w_{(b,c,d)})=(\{U_T\}, \{E_{1,1},E_{2,2},E_{3,3}\})$.
As before, $w_{(a,c,d)}$ and $w_{(b,c,d)}$ share the initial colour, while $w_{(a,b)}$ has its own.
For the second round we now get 
\begin{align*}
	\gamma_1(w_{(a,c,d)})=(\gamma_0(w_{(a,c,d)}), \leftmultiset
		&(\{E_{1,1}^+,E_{1,1}^-\}, \gamma_0(w_{(a,b)})), \\
		&(\{E_{2,2}^+,E_{3,3}^+, E_{2,2}^-, E_{3,3}^-\}, \gamma_0(w_{(b,c,d)})), \\
		&(\{E_{1,1}^+,E_{2,2}^+,E_{3,3}^+,E_{1,1}^-,E_{2,2}^-,E_{3,3}^-\}, \gamma_0(w_{(a,c,d)}))
	\rightmultiset)
\end{align*}
and
\begin{align*}
	\gamma_1(w_{(b,c,d)})=(\gamma_0(w_{(b,c,d)}), \leftmultiset
	&(\{E_{1,2}^+,E_{2,1}^-\}, \gamma_0(w_{(a,b)})), \\
	&(\{E_{2,2}^+,E_{3,3}^+, E_{2,2}^-, E_{3,3}^-\}, \gamma_0(w_{(a,c,d)})), \\
	&(\{E_{1,1}^+,E_{2,2}^+,E_{3,3}^+,E_{1,1}^-,E_{2,2}^-,E_{3,3}^-\}, \gamma_0(w_{(b,c,d)}))
	\rightmultiset).
\end{align*}
Again, $\gamma_1(w_{(a,c,d)})\neq \gamma_1(w_{(b,c,d)})$ and the algorithm terminates.
We see that both procedures act equally, which is what was proved by Scheidt and Schweikardt.

Let us now look at an example where RCR distinguishes two structures.
For this, consider the $\sigma$-structure $\mathfrak B=(B, R^{\mathfrak B}, T^{\mathfrak B})$ with $B=(a',b',c',d')$, $R^{\mathfrak B}=\{(c',d')\}$ and $T^{\mathfrak B}=\{(a',c',d'),(b',c',d')\}$, which can be seen in Figure \ref{fig:distinguishedByRCR}.
\begin{figure}
	\centering
	\begin{tikzpicture}
		\node[] at (0,0) (a) {$a'$};
		\node[] at (2, 0) (b) {$b'$};
		\node[] at (0, -2) (c) {$c'$};
		\node[] at (2, -2) (d) {$d'$};
		
		\node[fit=(a) (c) (d)] (acd) {};
		\draw[rounded corners=20pt, thick, rwth-red] ($(acd.north west)+(0,0.4)$) -- (acd.south west) -- ($(acd.south east)+(0.4,0)$) -- cycle;
		
		\node[fit=(b) (c) (d)] (bcd) {};
		\draw[rounded corners=20pt, thick, rwth-red] ($(bcd.north east)+(0,0.4)$) -- (bcd.south east) -- ($(bcd.south west)+(-0.4, 0)$) -- cycle;
		
		\node[draw, rounded corners=10pt, thick, rwth-blue, fit=(c) (d)] {};
	\end{tikzpicture}
	\caption{The $\sigma$-structure $\mathfrak B$ that gets distinguished by RCR from $\mathfrak A$.}
	\label{fig:distinguishedByRCR}
\end{figure}
It can easily be seen that every colour appears exactly as often in the colouring of the tuples of $\mathfrak A$ as of $\mathfrak B$.
Thus $\RCR$ cannot distinguish the structures in round $0$.
However, as $\mathfrak B$ does not include a tuple with $a'$ as the first element, the colour $\gamma_1((a,c,d))$ does not appear in round $1$ of RCR in $\mathfrak B$.
Therefore $\operatorname{mult}_{\mathfrak A}(\gamma_1((a,c,d)))=1\neq 0 = \operatorname{mult}_{\mathfrak B}(\gamma_1((a,c,d)))$ and RCR distinguishes $\mathfrak A$ and $\mathfrak B$ in round $1$.

In their paper, Scheidt and Schweikardt consider a larger example, which is an extension of the classical non-distinguishable example for Colour Refinement.
It uses a signature with a binary and a $6$-ary relation and is comprised of the structure $\mathfrak A_1$ with one $6$-cycle and the structure $\mathfrak A_2$ with two $3$-cycles.
Without the $6$-ary relation the structure would be a regular graph and therefore could not be distinguished by Colour Refinement.
Because of that, the $6$-ary relation is added with one tuple, containing all $6$ elements each.
With this change, the structures can be distinguished, which is discussed in \cite{scheidt2025ColorRefinement}.

Furthermore, Scheidt and Schweikardt investigate other, seemingly simpler, possible variants of Colour Refinement which use the Gaifman-Graph and Incidence-Graph of a relational structure.
However, these variants are not able to distinguish $\mathfrak A_1$ and $\mathfrak A_2$, which is why they are disregarded.

\subsection{Logical Characterisation of RCR}

Classical Colour Refinement gets characterised by counting logic with up to two variables, also called $\C{2}$.
This means that two graphs $G$ and $H$ get distinguished by Colour Refinement if, and only if, there is a sentence $\phi\in \C{2}$, such that $G\models \phi$ and $H\not\models \phi$ \cite{immerman1990DescribingGraphs}.
Similarly, Relational Colour Refinement is characterised by the guarded fragment of counting logic, in short $\GFC$.
This logic restricts first-order logic with counting quantifiers in the same way, as the guarded fragment of first-order logic $\mathsf{GF}$ restricts $\mathsf{FO}$.
An investigation of this notion of guards can be found in \cite{gradel1999RestrainingPower}.
This means that the bound on the number of variables is dropped, but the restriction that quantifiers need to be relativised by an atomic formula is added.

\begin{definition}[The guarded fragment of counting logic]
	\label{def:GFC}
	For a relational signature $\sigma$ we define the class $\GFC$ over $\sigma$ inductively using the following rules:
	\begin{enumerate}
		\item Let $R\in\sigma$ with $\ell=\operatorname{ar}(R)$ and let $x_1,\dots,x_\ell$ be variables. Then $R(x_1,\dots,x_\ell)\in \GFC$.
		\item Let $a$ and $y$ be two variables. 
		Then $x=y\in\GFC$.
		\item Let $\phi\in\GFC$.
		Then $\neg(\phi)\in\GFC$.
		\item Let $\phi,\psi,\in\GFC$. 
		Then $(\phi\land\psi)\in\GFC$.
		\item For a formula built using Rule \emph{1.} or \emph{2.} $\Delta$ and a $\phi\in\GFC$ we call $\Delta$ a guard for $\phi$, if $\free{\Delta}\supseteq\free{\phi}$.
		Let $\Delta,\phi\in \GFC$, where $\Delta$ is a guard for $\phi$, let $\mathbf v$ be a tuple of variables with $\set(\mathbf v)\subseteq \free{\Delta}$ and let $n\in \mathbb N_{\geq 1}$. 
		Then $\exists^{\geq n}\mathbf v . (\Delta \land \phi)\in \GFC$.
	\end{enumerate}
	Formulae that are built using Rules \emph{1.} and \emph{2.} are called atomic formulae, we omit parenthesises in the usual way and use $\exists^{=n}\mathbf v.(\Delta\land\phi)$ as shorthand notation for $\exists^{\geq n}\mathbf v.(\Delta\land\phi)\land \neg\exists^{\geq n+1}\mathbf v.(\Delta\land\phi)$.
	
	The semantics of this logic are analogous to classical Counting Logic, see for example \cite{cai1992OptimalLower}, and also are concretely defined in \cite{scheidt2025ColorRefinement}.
\end{definition}
We find that this logic is equivalent to the logic $\mathsf{GC}^1$ as it is defined by the same authors in \cite{scheidt2023CountingHomomorphisms}.

Using a pebble game for $\GFC$, called the Guarded-Game, Scheidt and Schweikardt proved the following theorem:
\begin{theorem}[Theorem B from \cite{scheidt2025ColorRefinement}]
	Let $\sigma$ be a relational signature and let $\mathfrak A$ and $\mathfrak B$ be $\sigma$-structures.
	Then the three following statements are equivalent:
	\begin{enumerate}
		\item Relational Colour Refinement distinguishes $\mathfrak A$ and $\mathfrak B$.
		\item There exists a sentence $\phi\in \GFC$ such that $\mathfrak A\models \phi$ and $\mathfrak B\not\models\phi$.
		\item Spoiler wins the Guarded-Game on $\mathfrak A$ and $\mathfrak B$.
	\end{enumerate}
\end{theorem}
Let us again consider the structures from Figures \ref{fig:verySimpleRelStruc} and \ref{fig:distinguishedByRCR}.
In the preceding section we used the colour $\rho_1((a,c,d))$ to distinguish $\mathfrak A$ and $\mathfrak B$, as it does not appear in the colouring of $\mathfrak B$.
More precisely, there does not exist a tuple of length $3$ in $\mathfrak B$, which is in the relation $T$ and its first element is in the relation $R$ with another element.
This can be formalised using the formula
$$\phi_1\coloneqq\exists^{\geq 1}(x,y,z).\left(T(x,y,z)\land \exists^{\geq 1} (y).\left( R(x,y)\right)\right).$$
It is easy to see that $\mathfrak A\models \phi_1$ and $\mathfrak B\not\models \phi_1$.
Another formula can be obtained from the fact that in the stable colouring of $\mathfrak B$, the tuples $(a,c,d)$ and $(b,c,d)$ share the same colour.
Therefore, the formula
$$\phi_2\coloneqq \exists^{\geq 2}(x,y,z).\left(T(x,y,z)\land R(y,z)\right)$$
is also distinguishing.

\subsection{Characterising RCR by Homomorphism Counting}

Another way to characterise classical CR is to count homomorphisms from trees.
Due to \cite{dvorak2010RecognizingGraphsa} and \cite{dell2018LovaszMeets} it is known that Colour Refinement distinguishes two graphs $G$ and $H$ if, and only if, there is a tree $T$, such that $\hom(T,G)\neq\hom(T,H)$.
Again, there is an analogous characterisation for Relational Colour Refinement.
One obstacle in defining such a characterisation is finding a class that generalises trees for relational structures.
As a tree is a connected, acyclic graph, we have to find a fitting notion of acyclicity for relational structures.
As can be seen in \cite{brault-baron2014HypergraphAcyclicity}, there are multiple such definitions possible for hypergraphs, which can be applied to relational structures as well.
When considering the results from \cite{scheidt2023CountingHomomorphisms} and that $\mathsf{GC}^1$ characterises RCR, it becomes clear that hypergraphs of generalised hypertree width of $1$, or equivalently $\alpha$-acyclic hypergraphs, may be a possible candidate.
This is in fact the case.
Let us therefore define $\alpha$-acyclic structures, or in the following just acyclic structures.

\begin{definition}[Acyclic structures]
	\label{def:alphaAcyclic}
	Let $\sigma$ be relational signature and let $\mathfrak C$ be a $\sigma$-structure.
	A join-tree $J$ for $\mathfrak C$ is a tree with a vertex for every tuple in $\mathfrak C$, thus $V(J)=\mathbf C$, which fulfils the join-tree-property:
	For any $c\in C$, the set $\{\mathbf c \in V(J) : c\in \set(\mathbf c)\}$ induces a connected subgraph of $J$.
	This induced subgraph is also a tree and will be denoted as $J_c$.
	Finally, we call structure acyclic, if it has a join-tree.
\end{definition}
There are multiple equivalent characterisations for this notion of acyclicity which can be found in \cite{brault-baron2014HypergraphAcyclicity}.
Recall the definition for homomorphisms between structures and the definitions of $\Hom$ and $\hom$.
This then leads us to another main result from \cite{scheidt2025ColorRefinement}.

\begin{theorem}[Theorem A from \cite{scheidt2025ColorRefinement}]
	Let $\sigma$ be a relational signature and let $\mathfrak A$ and $\mathfrak B$ be $\sigma$-structures.
	Then the two following statements are equivalent:
	\begin{enumerate}
		\item Relational Colour Refinement distinguishes $\mathfrak A$ and $\mathfrak B$.
		\item There exists an acyclic $\sigma$-structure $\mathfrak C$, such that $\hom(\mathfrak C,\mathfrak A)\neq\hom(\mathfrak C,\mathfrak B)$.
	\end{enumerate}
\end{theorem}

We again want to consider the structures from Figures \ref{fig:verySimpleRelStruc} and \ref{fig:distinguishedByRCR} for a simple example.
The structure $\mathfrak B$ is acyclic.
This can be seen from its join tree depicted in Figure \ref{fig:distinguishedJoinTree}.
\begin{figure}
	\centering
	\begin{tikzpicture}[node distance=1cm]
		\node[draw, rounded corners=8pt] (cd) {$(c',d')$};
		\node[draw, rounded corners=8pt, below left=of cd] (acd) {$(a',c',d')$};
		\node[draw, rounded corners=8pt, below right=of cd] (bcd) {$(b',c',d')$};
		
		\draw
		(cd) edge[-] (acd)
		(cd) edge[-] (bcd);
	\end{tikzpicture}
	\caption{A join-tree for the structure $\mathfrak B$ from Figure \ref{fig:distinguishedByRCR}}
	\label{fig:distinguishedJoinTree}
\end{figure}
Now consider the homomorphisms from $\mathfrak B$.
The identity is always a homomorphism, therefore $\hom(\mathfrak B, \mathfrak B)\geq 1$.
However, when trying to construct a homomorphism from $\mathfrak B$ to $\mathfrak A$, we encounter some issues.
As $(c',d')\in R^{\mathfrak B}$ and $(a,b)$ is the only tuple in $R^{\mathfrak A}$, we have to map $c'$ to $a$ and $d'$ to $b$.
But now consider the tuple $(a',c',d')\in T^{\mathfrak B}$ and let $x$ be the element that $a'$ gets mapped to.
Then $(x,a,b)$ must be in $T^{\mathfrak A}$.
But there is no such tuple in $\mathfrak A$, independently of $x$.
Therefore there cannot exist a homomorphism from $\mathfrak B$ to $\mathfrak A$, thus $\hom(\mathfrak B, \mathfrak A)=0\neq \hom(\mathfrak B, \mathfrak B)$ and $\mathfrak B$ is an acyclic structure that distinguishes $\mathfrak B$ and $\mathfrak A$ by homomorphism count.
 
