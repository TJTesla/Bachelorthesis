%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% i7 Seminar Report Template
% Version November 8, 2023

\documentclass[a4paper,11pt,DIV=15]{scrartcl} % Do not edit this line.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Preamble

% Page Geometry, Typography and Encoding
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage{lmodern}
\renewcommand{\phi}{\varphi}
\renewcommand{\epsilon}{\varepsilon}
% \renewcommand{theta}{\vartheta} % if you want

% Math packages
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}

% Floats
\usepackage{float}
\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{positioning,arrows.meta}

% Colors
\usepackage{xcolor} %already loaded by tikz, but here for completeness
% RWTH colors
% blue violet purple carmine red magenta orange yellow grass cyan gold silver
\definecolor{rwth-blue}{cmyk}{1,.5,0,0}\colorlet{rwth-lblue}{rwth-blue!50}\colorlet{rwth-llblue}{rwth-blue!25}
\definecolor{rwth-violet}{cmyk}{.6,.6,0,0}\colorlet{rwth-lviolet}{rwth-violet!50}\colorlet{rwth-llviolet}{rwth-violet!25}
\definecolor{rwth-purple}{cmyk}{.7,1,.35,.15}\colorlet{rwth-lpurple}{rwth-purple!50}\colorlet{rwth-llpurple}{rwth-purple!25}
\definecolor{rwth-carmine}{cmyk}{.25,1,.7,.2}\colorlet{rwth-lcarmine}{rwth-carmine!50}\colorlet{rwth-llcarmine}{rwth-carmine!25}
\definecolor{rwth-red}{cmyk}{.15,1,1,0}\colorlet{rwth-lred}{rwth-red!50}\colorlet{rwth-llred}{rwth-red!25}
\definecolor{rwth-magenta}{cmyk}{0,1,.25,0}\colorlet{rwth-lmagenta}{rwth-magenta!50}\colorlet{rwth-llmagenta}{rwth-magenta!25}
\definecolor{rwth-orange}{cmyk}{0,.4,1,0}\colorlet{rwth-lorange}{rwth-orange!50}\colorlet{rwth-llorange}{rwth-orange!25}
\definecolor{rwth-yellow}{cmyk}{0,0,1,0}\colorlet{rwth-lyellow}{rwth-yellow!50}\colorlet{rwth-llyellow}{rwth-yellow!25}
\definecolor{rwth-grass}{cmyk}{.35,0,1,0}\colorlet{rwth-lgrass}{rwth-grass!50}\colorlet{rwth-llgrass}{rwth-grass!25}
\definecolor{rwth-green}{cmyk}{.7,0,1,0}\colorlet{rwth-lgreen}{rwth-green!50}\colorlet{rwth-llgreen}{rwth-green!25}
\definecolor{rwth-cyan}{cmyk}{1,0,.4,0}\colorlet{rwth-lcyan}{rwth-cyan!50}\colorlet{rwth-llcyan}{rwth-cyan!25}
\definecolor{rwth-teal}{cmyk}{1,.3,.5,.3}\colorlet{rwth-lteal}{rwth-teal!50}\colorlet{rwth-llteal}{rwth-teal!25}
\definecolor{rwth-gold}{cmyk}{.35,.46,.7,.35}
\definecolor{rwth-silver}{cmyk}{.39,.31,.32,.14}

% Hyperlinks and Cross-References
\usepackage{hyperref}
\usepackage[capitalise,noabbrev]{cleveref}
\hypersetup{%
	pdftoolbar=false,
	pdfmenubar=false,
	colorlinks,
	%pdfborderstyle={/S/U/W 1.25},
	urlcolor={rwth-magenta},
	linkcolor={rwth-red},
	citecolor={rwth-green}
}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{claim}[theorem]{Claim}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}



% Misc packages
\usepackage{lipsum}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document


\begin{document}

%TODO Insert topic of seminar, e.g. Theoretical Topics in Data Science or Complexity Theory
\subtitle{Bachelor Thesis Concept}
\date{\today}
\publishers{RWTH Aachen University}	% Do not edit this line.

%TODO Change this to your report title.
\title{Thesis Concept: Relational Colour Refinement for Non-Relational Signatures}

%TODO Change this to your name.
\author{Theodor Teslia}

\maketitle

\section{Introduction}

Colour Refinement is a well-understood algorithm that can be applied in a lot of situations.
The original application of the procedure is graph isomorphism testing.
Colour Refinement colours the vertices of a graph in such a way that a different colouring implies that the graphs cannot be isomorphic.
As a consequence, Colour Refinement can detect that two graphs are not isomorphic, but the converse does not hold.
However, there are also other fields where the algorithm can be applied.
For example Linear Programming, where it can be used as a pre-processing step to find a smaller, but equivalent, problem or Machine Learning, where colour refinement can accelerate computations for kernel methods \cite{grohe2021color}.

Furthermore, the simple procedure has been generalized to the $k$-dimensional Weisfeiler-Leman Algorithm, where Colour Refinement is the $1$-dimensional variant.
This expansion makes it possible to colour non-isomorphic graphs differently, which would receive the same colouring from normal Colour Refinement \cite{kiefer2020power}.
\\ \\
As mentioned, Colour Refinement is an algorithm that operates on graphs.
Another interesting direction of research is to find a similar algorithm that operates on structures that are more complex than graphs.

A first step in that direction is Colour Refinement for coloured multigraphs, which are vertex-coloured binary structures. 
This can be achieved by adapting the colours of the Colour Refinement to also include the vertex and edge colours. \cite{scheidt2024color}
A further widening to hypergraphs, graphs that admit edges between any number of vertices, has been made by Scheidt and Schweikardt \cite{scheidt2023counting}.
The generalization to arbitrary relational structures has been achieved by the same authors in \cite{scheidt2024color}, which will serve as a basis of the thesis.

\section{Background}

This section aims to explain and define Colour Refinement and its Relational version.

\subsection{Colour Refinement} \label{sec::CR}

Colour Refinement is a simple iterative algorithm which aims to find a colouring of the vertices of a graph.
Initially, every vertex receives the same colour. 
After this, the colouring gets iteratively refined where the next colour of a vertex is determined by its current one and the multiset of colours of its neighbours.
This process is repeated until it stabilizes, i.e. the partition of the vertices induced by the colouring stays the same. This colouring is then called the stable colouring.

If the stable colourings of two graphs are different, we say that Colour Refinement distinguishes the graphs.
This means that there is a colour which occurs a different number of times in the colouring of one graph than in the colouring of the other.

As the iterative step only uses the computed colours and amount of neighbour vertices, it is a very efficient procedure.
In fact, Berkholz, Bonsma and Grohe showed Colour Refinement to be computable in $\mathcal O((n+m)\cdot\log (n))$ \cite{berkholz2017TightLower}.
For a formal definition of Colour Refinement see e.g. \cite{kiefer2020power}, \cite{scheidt2024color} or \cite{grohe2021color}.

One very interesting aspect of Colour Refinement is its characterisation through combinatorics and logic.
Due to Dvo\v r\'ak \cite{dvovrak2010recognizing} and Dell, Grohe and Rattan \cite{dell2018LovaszMeets} we obtain the following statement:
\begin{center}
	Two graphs $G$ and $G'$ are distinguished by Colour Refinement.
	\\ $\Longleftrightarrow$ \\ 
	There exists a tree $T$ s.t. the number of homomorphisms from $T$ to $G$ is different from the number of homomorphisms from $T$ to $G'$.
\end{center}
Furthermore Cai, FÃ¼rer and Immerman showed that the fragment of first-order logic with counting quantifiers and up to two variables ($\mathsf C^2$) characterises Colour Refinement \cite{cai1992optimal}:
\begin{center}
	Two graphs $G$ and $G'$ are distinguished by Colour Refinement.
	\\ $\Longleftrightarrow$ \\ 
	There exists a sentence $\varphi\in \mathsf C^2$ s.t. $G\models \varphi$ and $G'\not\models\varphi$.
\end{center}

\subsection{Relational Colour Refinement}

The key idea of Relational Colour Refinement (RCR) is to colour tuples of elements that appear in some relation instead of the specific elements themselves. 
The colouring uses the atomic type $\mathsf{atp}(\mathbf{a})=\{R\in\sigma : \mathbf{a}\in R\}$ (the set of relations that include $\mathbf{a}$) as well as the similarity type $\mathsf{stp}(\mathbf{a},\mathbf{b})=\{(i,j)\in[k]\times[\ell] : a_i=b_j\}$ (the set of pairs of indices for equal elements) where $\mathbf{a}$ and $\mathbf{b}$ are of arity $k$ and $\ell$, respectively.
When compared to Colour Refinement on coloured multigraphs, we find that the atomic type acts like the colouring of the vertices, while the similarity types play the role of the different edges.

This algorithm is shown to be equivalent to Colour Refinement on a graph that is constructed from the relational structure, by using the tuples as vertices and the shared types as edges.
In fact, this translation to the traditional Colour Refinement can then be used to state the running time of RCR to be in $\mathcal O(\Vert \mathfrak A\vert\cdot \log\Vert\mathfrak A\Vert)$.

One interesting attribute of RCR is that it allows for two characterisations that are analogous to those of normal Colour Refinement. Those will be described in the following. \cite{scheidt2024color}
\\ \\
As discussed in \cref{sec::CR}, Colour Refinement can be characterised by the number of homomorphisms from trees to graphs.
To achieve a similar result for RCR, a generalisation of trees to relational structures is needed.
A suitable definition is that of acyclic structures as they are used in database theory \cite{abiteboul1995foundations}.
A formal definition can be found in \cite{scheidt2024color}.
With this definition a main result of \cite{scheidt2024color} can be stated:
\begin{center}
	Two relational structures $\mathfrak A$ and $\mathfrak B$ are distinguished by RCR.
	\\ $\Longleftrightarrow$ \\ 
	There exists an acyclic structure $\mathfrak C$ such that the number of homomorphisms from $\mathfrak C$ to $\mathfrak A$ is different from the number of homomorphisms from $\mathfrak C$ to $\mathfrak B$.
\end{center}
\hfill
\\
As seen in \cref*{sec::CR}, Colour Refinement can be characterised logically.
Again a similar result has been achieved for RCR.
However, instead of by $\mathsf C^2$, RCR can be characterised by $\mathsf{GF}(\mathsf C)$, the guarded fragment of first-order logic with counting quantifiers.

This logic depends on the definition of a guard: 
Let $\operatorname{free}(\varphi)$ be the set of variables that appear freely in $\varphi$.
Now let $\Delta$ be an atomic formula and $\psi$ be an arbitrary formula of $\mathsf{GF}(\mathsf C)$.
If $\operatorname{free}(\Delta)\supseteq\operatorname{free}(\psi)$, then we call $\Delta$ a guard for $\psi$.
Let $v_1,\dots,v_k$ be variables with $v_i\in \operatorname{free}(\Delta)$ for all $i\in[k]$ and $\mathbf v = (v_1,\dots,v_k)$.
$\mathsf{GF}(\mathsf C)$ is the fragment of $\mathsf C$, where quantifiers only appear of the form $\exists^{\geq n}\mathbf v.(\Delta \land \psi)$ where $\Delta$ is a guard for $\psi$.

By taking this logical characterisation and the results from above, we can state the end-result of \cite{scheidt2024color}:

\begin{theorem}[Scheidt, Schweikardt \cite{scheidt2024color}]
	Let $\mathfrak A$ and $\mathfrak B$ be relational structures. The following statements are equivalent:
	\begin{enumerate}
		\item Relational Color Refinement distinguishes $\mathfrak A$ and $\mathfrak B$.
		\item There exists an acyclic structure $\mathfrak C$ s.t. the number of homomorphisms from $\mathfrak C$ to $\mathfrak A$ is different from the number of homomorphisms from $\mathfrak C$ to $\mathfrak B$.
		\item There is a sentence $\varphi\in \mathsf{GF}(\mathsf C)$ such that $\mathfrak A\models\varphi$ and $\mathfrak B\not\models\varphi$.
	\end{enumerate}
	\label{RCRMainThm}
\end{theorem}

\section{Objectives}
\label{Sec::Objectives}

The objectives and aims of the thesis are to explore the robustness of the results of \cite{scheidt2024color} and find potential expansions. 
Primarily the applicability and adaptability to other classes of structures will be examined.
\\ \\
\cref{RCRMainThm} only considers relational signatures, but for example not functional ones.
However, as the generalisation from graphs to relational structures is possible, it poses the question whether a further widening to arbitrary signatures is achievable.
For this, constant symbols, unary functions, and functions of arbitrary arity could be included in the signature.

This thesis will consider, how the given definitions need to be adapted to work with function symbols, i.e. can $\mathsf{GF(C)}$ also work with functions, do functions impact the acyclic property of structures?
Further the definition of RCR needs to be investigated and adapted to also work with function symbols.

As they are considerably simpler, those questions will first be considered for unary functions and then later increased to functions of higher arity.
\label{StructWFunc}
\\ \\
A relational structure with symmetric relations is a structure $\mathfrak A$, where for all relations $R^\mathfrak A$ of arity $k$ it holds $R^\mathfrak A \subseteq \binom{A}{k}$, i.e. the order of elements inside a tuple does not matter.

As those structures are relational, \cref{RCRMainThm} obviously applies to them.
However, this trivial implication does not apply, if we also restrict the other sides of the equivalence.
In particular, does it still hold, if instead of acyclic structures we only use symmetric acyclic structures?
Or can we restrict parts of the distinguishing sentence to be of a certain form?

A possible approach could be inspired by \cite{scheidt2023counting}, since symmetric structures and hypergraphs seem to be similar in some form.
\label{SymmStruct}

\section{Structure}

First I will begin with an introduction to Colour Refinement on graphs and the existing results for it. Further the Relational Colour Refinement due to \cite{scheidt2024color} will be defined and explained through own examples.

After explaining the underlying algorithms, logics and structures, such that the results of \cite{scheidt2024color} can be explained, I will move onto the questions and problems stated in \cref{Sec::Objectives}.

At the end, I will conclude my results, put them into context, point out possible problems and state approaches for further work.


\bibliographystyle{plainurl}
\bibliography{references.bib}



\end{document}





